from __future__ import annotations

import asyncio
from typing import Any, Dict, Optional, Set

import discord

from starz_core.discord_queue import qsend

from starz_core.tickets.ticket_helpers import (
    handle_ticket_claim_message,
    note_ticket_opener,
    maybe_handle_close_message,
)

from starz_core.tickets.kit_helpers import (
    kit_first_help,
    looks_like_kit_question,
    looks_like_kit_issue,
)

from starz_core.tickets.workflows import (
    process_workflow_answer,
    ADMIN_ABUSE_KEYWORDS,
    ZORP_ISSUE_KEYWORDS,
    REFUND_KEYWORDS,
    KIT_ISSUE_WORKFLOW_KEYWORDS,
    start_admin_abuse_workflow,
    start_zorp_issue_workflow,
    start_refund_workflow,
    start_kit_issue_workflow,
)

from starz_core.tickets.ticket_ai import maybe_handle_ticket_ai_message


# ----------------------------
# Ticket router state
# ----------------------------
active_ai_channels: Set[int] = set()
ai_greeting_sent: Set[int] = set()
ticket_sessions: Dict[int, Dict[str, Any]] = {}


def build_ai_greeting_embed(opener: Optional[discord.Member] = None) -> discord.Embed:
    desc = "Hello, I'm **Otis**. How can I help you today?"
    if opener is not None:
        desc = f"Hello {opener.mention}, I'm **Otis**. How can I help you today?"
    return discord.Embed(
        title="STARZ AI ADMIN (Otis)",
        description=desc,
        color=0x3498DB,
    )


class AIToggleView(discord.ui.View):
    def __init__(self, channel_id: int, enabled: bool = True):
        super().__init__(timeout=None)
        self.channel_id = channel_id

        if enabled:
            active_ai_channels.add(channel_id)
        else:
            active_ai_channels.discard(channel_id)

        self.toggle_button = discord.ui.Button(
            label="Disable Otis" if enabled else "Enable Otis",
            style=discord.ButtonStyle.danger if enabled else discord.ButtonStyle.success,
            custom_id=f"toggle_ai_{channel_id}",
        )
        self.toggle_button.callback = self.on_toggle_clicked
        self.add_item(self.toggle_button)

    async def on_toggle_clicked(self, interaction: discord.Interaction):
        user = interaction.user

        # NOTE: permissions check should be handled in bot.py or pass roles in.
        # Here we only toggle.
        if self.channel_id in active_ai_channels:
            active_ai_channels.discard(self.channel_id)
            self.toggle_button.label = "Enable Otis"
            self.toggle_button.style = discord.ButtonStyle.success
            msg = "ðŸŸ¢ Otis disabled for this ticket."
        else:
            active_ai_channels.add(self.channel_id)
            self.toggle_button.label = "Disable Otis"
            self.toggle_button.style = discord.ButtonStyle.danger
            msg = "ðŸ”´ Otis enabled for this ticket."

        try:
            await interaction.message.edit(view=self)
        except Exception:
            pass

        await interaction.response.send_message(msg, ephemeral=True)


async def ensure_ai_control_message(
    bot: discord.Client,
    channel: discord.TextChannel,
    opener: Optional[discord.Member],
) -> None:
    """Send the Otis greeting embed once per ticket."""
    if channel.id in ai_greeting_sent:
        return

    ai_greeting_sent.add(channel.id)
    active_ai_channels.add(channel.id)

    # Check recent history for an existing Otis embed
    try:
        async for msg in channel.history(limit=25):
            if msg.author == bot.user and msg.embeds:
                emb = msg.embeds[0]
                if emb.title == "STARZ AI ADMIN (Otis)":
                    return
    except Exception:
        pass

    view = AIToggleView(channel.id, enabled=True)
    embed = build_ai_greeting_embed(opener)

    await asyncio.sleep(0.5)
    await qsend(lambda: channel.send(embed=embed, view=view))


def _is_ticket_channel(channel: discord.TextChannel, ticket_category_ids: Set[int]) -> bool:
    # Category-based tickets
    if channel.category and channel.category.id in ticket_category_ids:
        return True
    # Tickets v2 name-based
    if channel.name.lower().startswith("ticket-"):
        return True
    return False


async def maybe_handle_ticket_message(
    *,
    bot: discord.Client,
    client_ai,
    message: discord.Message,
    style_text: str,
    rules_text: str,
    zorp_guide_text: str,
    raffle_text: str,
    ticket_category_ids: Set[int],
    ai_control_roles: Set[int],
) -> bool:
    """
    Returns True if the message was handled as a ticket message (and bot.py should stop).
    """
    if not isinstance(message.channel, discord.TextChannel):
        return False

    channel: discord.TextChannel = message.channel

    # Not a ticket? ignore
    if not _is_ticket_channel(channel, ticket_category_ids):
        return False

    # Track opener (first human)
    if not message.author.bot:
        try:
            note_ticket_opener(channel, message.author)
        except Exception as e:
            print(f"[TICKETS] note_ticket_opener error: {e}")

    # Tickets v2 claim embeds
    if message.author.bot and message.embeds:
        try:
            await handle_ticket_claim_message(message)
        except Exception as e:
            print(f"[TICKETS] handle_ticket_claim_message error: {e}")

        if channel.id not in ai_greeting_sent:
            await ensure_ai_control_message(bot, channel, opener=None)

        return True

    # No AI on other bot messages
    if message.author.bot:
        return True

    # Close handling
    try:
        closed = await maybe_handle_close_message(message)
        if closed:
            return True
    except Exception as e:
        print(f"[TICKETS] maybe_handle_close_message error: {e}")

    # If Otis disabled for this ticket
    if channel.id not in active_ai_channels:
        return True

    content = (message.content or "").strip()
    if not content:
        return True

    lower_content = content.lower()

    # If staff member speaks, disable OTIS permanently in this ticket
    is_staff = False
    if isinstance(message.author, discord.Member):
        is_staff = any(r.id in ai_control_roles for r in message.author.roles)
    if is_staff:
        active_ai_channels.discard(channel.id)
        sess = ticket_sessions.get(channel.id)
        if sess is not None:
            sess["ai_disabled"] = True
        return True

    opener = message.author if isinstance(message.author, discord.Member) else None

    # Workflow intake continuation
    try:
        consumed = await process_workflow_answer(bot, message)
    except Exception as e:
        print(f"[WORKFLOWS] process_workflow_answer error: {e}")
        consumed = False
    if consumed:
        return True

    # Workflow triggers
    if any(k in lower_content for k in ADMIN_ABUSE_KEYWORDS):
        await start_admin_abuse_workflow(channel, opener)
        return True

    if any(k in lower_content for k in ZORP_ISSUE_KEYWORDS):
        await start_zorp_issue_workflow(channel, opener)
        return True

    if any(k in lower_content for k in REFUND_KEYWORDS):
        await start_refund_workflow(channel, opener)
        return True

    if any(k in lower_content for k in KIT_ISSUE_WORKFLOW_KEYWORDS):
        await start_kit_issue_workflow(channel, opener)
        return True

    # Kit helper quick help
    try:
        if looks_like_kit_question(content) or looks_like_kit_issue(content):
            helped = await kit_first_help(message, channel, content)
            if helped:
                return True
    except Exception as e:
        print(f"[KITS] kit_first_help error: {e}")

    # Main AI
    try:
        await maybe_handle_ticket_ai_message(
            bot=bot,
            client_ai=client_ai,
            message=message,
            style_text=style_text,
            rules_text=rules_text,
            zorp_guide_text=zorp_guide_text,
            raffle_text=raffle_text,
            ticket_sessions=ticket_sessions,
            ticket_category_ids=ticket_category_ids,
            ai_control_roles=ai_control_roles,
        )
    except Exception as e:
        print(f"[TICKETS] maybe_handle_ticket_ai_message error: {e}")

    return True
