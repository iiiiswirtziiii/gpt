from __future__ import annotations

import asyncio
import json
import time
from datetime import datetime, UTC
from typing import Callable, Dict, List, Optional

import discord
import websockets

from starz_core.discord_queue import qsend
from starz_core.rcon.router import handle_rcon_console_line

IsEnabled = Callable[[], bool]


class RconConsoleWatchManager:
    def __init__(
        self,
        *,
        bot: discord.Client,
        rcon_configs: Dict[str, Dict[str, object]],
        is_enabled: IsEnabled,
        disconnect_channel_id: int,
        disconnect_cooldown_seconds: int = 600,
        # Optional: pause printpos while unstable
        set_printpos_enabled: Optional[Callable[[bool], None]] = None,
    ):
        self.bot = bot
        self.rcon_configs = rcon_configs
        self.is_enabled = is_enabled
        self.disconnect_channel_id = disconnect_channel_id
        self.disconnect_cooldown_seconds = disconnect_cooldown_seconds
        self.set_printpos_enabled = set_printpos_enabled

        self._tasks: List[asyncio.Task] = []
        self._last_alert_ts: Dict[str, float] = {}

    def started(self) -> bool:
        return bool(self._tasks)

    def start(self) -> None:
        if self._tasks:
            return

        for server_key, cfg in self.rcon_configs.items():
            host = str(cfg["host"])
            port = int(cfg["port"])
            password = str(cfg["password"])

            t = asyncio.create_task(
                self._watch_server(server_key, host, port, password),
                name=f"rcon_watch_{server_key}",
            )
            self._tasks.append(t)

        print(f"[RCON-WATCH] Started {len(self._tasks)} console watcher task(s).")

    async def _send_disconnect_alert(self, server_key: str, error: str) -> None:
        now = datetime.now(UTC).timestamp()
        last = self._last_alert_ts.get(server_key, 0.0)

        if now - last < float(self.disconnect_cooldown_seconds):
            return

        self._last_alert_ts[server_key] = now

        # Pause printpos/TP if provided
        if self.set_printpos_enabled is not None:
            try:
                self.set_printpos_enabled(False)
            except Exception:
                pass

        ch = self.bot.get_channel(self.disconnect_channel_id)
        if not isinstance(ch, discord.TextChannel):
            print(f"[RCON-ALERT] Channel {self.disconnect_channel_id} not found.")
            return

        embed = discord.Embed(
            title="⚠️ RCON Connection Lost",
            description=(
                f"**Server:** `{server_key}`\n"
                f"**Error:** `{error}`\n"
                f"**Time:** <t:{int(now)}:F>"
            ),
            color=0xE67E22,
        )
        await qsend(lambda: ch.send(embed=embed))

    async def _watch_server(self, server_key: str, host: str, port: int, password: str) -> None:
        url = f"ws://{host}:{port}/{password}/"
        print(f"[RCON-WATCH:{server_key}] Starting watcher for {host}:{port}")

        while True:
            if not self.is_enabled():
                await asyncio.sleep(30)
                continue

            try:
                print(f"[RCON-WATCH:{server_key}] Connecting to {url} ...")
                async with websockets.connect(url, ping_interval=None) as ws:
                    print(f"[RCON-WATCH:{server_key}] ✅ Connected, streaming logs...")

                    # Re-enable printpos/TP if provided
                    if self.set_printpos_enabled is not None:
                        try:
                            self.set_printpos_enabled(True)
                        except Exception:
                            pass

                    async for raw in ws:
                        try:
                            data = json.loads(raw)
                        except Exception:
                            continue

                        msg_text = (data.get("Message") or "").replace("\u0000", "").strip()
                        if not msg_text:
                            continue

                        created_at_ts = time.time()

                        # Always pass line to the unified router
                        try:
                            await handle_rcon_console_line(
                                self.bot,
                                server_key=server_key,
                                msg_text=msg_text,
                                created_at_ts=created_at_ts,
                            )
                        except Exception as e:
                            print(f"[RCON-WATCH:{server_key}] router error: {e}")

            except Exception as e:
                err = str(e)
                print(f"[RCON-WATCH:{server_key}] WebRCON error: {err}")

                try:
                    await self._send_disconnect_alert(server_key, err)
                except Exception as alert_err:
                    print(f"[RCON-ALERT] Failed to send alert: {alert_err}")

                await asyncio.sleep(10)
