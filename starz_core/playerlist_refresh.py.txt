# starz_core/playerlist_refresh.py
from __future__ import annotations

import asyncio
import json
from typing import Callable, Awaitable, Any, Dict, List, Optional

import discord
from discord.ext import tasks


# Injected dependencies (set by init_playerlist_refresh)
_bot: Optional[discord.Client] = None
_run_rcon_command: Optional[Callable[[str], Awaitable[Any]]] = None
_update_connected_players: Optional[Callable[[str, List[str]], Any]] = None
_rcon_configs: Optional[Dict[str, Any]] = None
_is_rcon_enabled: Optional[Callable[[], bool]] = None

_refresh_seconds: int = 20
_started: bool = False


def _parse_names_from_playerlist(text: str) -> list[str]:
    """
    Parse Rust Console 'playerlist' response into a list of DisplayName strings.

    Handles:
    - JSON list of dicts
    - double-encoded JSON strings
    - wrapping quotes
    - literal \\n / escapes
    """
    if not text:
        return []

    raw = str(text).strip()

    # Strip wrapping quotes if present
    if len(raw) >= 2 and raw[0] in ("'", '"') and raw[-1] == raw[0]:
        raw = raw[1:-1].strip()

    # Unescape literal \n etc if present
    if "\\n" in raw or "\\t" in raw or '\\"' in raw:
        try:
            raw = raw.encode("utf-8").decode("unicode_escape")
        except Exception:
            pass

    try:
        data = json.loads(raw)
        # Sometimes it's JSON-of-a-string (double encoded)
        if isinstance(data, str):
            data = json.loads(data)
    except Exception as e:
        print(f"[PLAYERLIST] JSON parse failed: {e}")
        print(f"[PLAYERLIST] raw_head={raw[:120]!r}")
        return []

    names: list[str] = []
    if isinstance(data, list):
        for row in data:
            if not isinstance(row, dict):
                continue
            name = row.get("DisplayName") or row.get("displayName") or row.get("Name")
            if not name:
                continue
            s = str(name).strip()
            if s:
                names.append(s)

    # de-dupe, keep order
    out: list[str] = []
    seen = set()
    for n in names:
        if n not in seen:
            seen.add(n)
            out.append(n)

    return out


@tasks.loop(seconds=20)
async def _playerlist_refresh_loop() -> None:
    # This loop depends on injected globals; be strict.
    if _bot is None:
        return

    await _bot.wait_until_ready()

    if _is_rcon_enabled is not None:
        try:
            if not _is_rcon_enabled():
                return
        except Exception:
            # If the checker fails, do nothing rather than crash.
            return

    if _run_rcon_command is None or _update_connected_players is None or _rcon_configs is None:
        return

    for server_key in _rcon_configs.keys():
        try:
            resp = await _run_rcon_command(f"playerlist::{server_key}")

            # Normalize response text (dict wrappers vary)
            if isinstance(resp, dict):
                text = (
                    resp.get("Response")
                    or resp.get("response")
                    or resp.get("Message")
                    or resp.get("message")
                    or ""
                )
            else:
                text = str(resp or "")

            names = _parse_names_from_playerlist(text)

            print(f"[PLAYERLIST] {server_key}: loaded {len(names)} name(s).")
            _update_connected_players(server_key, names)

            # tiny delay so we don't hammer RCON if you have 10 servers
            await asyncio.sleep(0.15)

        except Exception as e:
            print(f"[PLAYERLIST] {server_key}: refresh failed: {e}")


def init_playerlist_refresh(
    *,
    bot: discord.Client,
    run_rcon_command: Callable[[str], Awaitable[Any]],
    rcon_configs: Dict[str, Any],
    update_connected_players: Callable[[str, List[str]], Any],
    refresh_seconds: int = 20,
    is_rcon_enabled: Optional[Callable[[], bool]] = None,
) -> None:
    """
    Inject dependencies and configure the loop interval.
    Call once from bot.py (on_ready).
    """
    global _bot, _run_rcon_command, _update_connected_players, _rcon_configs, _is_rcon_enabled, _refresh_seconds

    _bot = bot
    _run_rcon_command = run_rcon_command
    _update_connected_players = update_connected_players
    _rcon_configs = rcon_configs
    _is_rcon_enabled = is_rcon_enabled
    _refresh_seconds = int(refresh_seconds)

    # Update loop seconds dynamically
    try:
        _playerlist_refresh_loop.change_interval(seconds=_refresh_seconds)
    except Exception:
        pass


def start_playerlist_refresh() -> None:
    """
    Start the refresh loop once. Safe to call multiple times.
    """
    global _started
    if _started:
        return
    _playerlist_refresh_loop.start()
    _started = True
    print(f"[PLAYERLIST] Refresh loop started every {_refresh_seconds}s.")
